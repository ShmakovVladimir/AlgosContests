# Обходы графов
[**Задача A-Проверить связность графа**](https://github.com/ShmakovVladimir/AlgosContests/blob/main/test27/A.py)
[**B-Подсчёт весов компонент связности неориентированного графа**](https://github.com/ShmakovVladimir/AlgosContests/blob/main/test27/B.py)
[**C-Проверка ацикличности графа**](https://github.com/ShmakovVladimir/AlgosContests/blob/main/test27/C.py)


## Алгоритм DFS
Алгоритм обходит все вершины, доступные из некоторой начальной вершины [start]

Последовательность дейтсвий алгоритма такая:
1. Пойти в какую-то смежную, не посещенную ранее вершину из даннной
2. Обойти все доступные вершины из данной вершины, помечая их как посещенные
3. Вернуться в начальную вершину
4. Повторять шаги 1-3 для всех вершин смежных с начальной

### Проверка связности неориентированного графа используя DFS

Для проверки связности запустим алгоритм из некоторой начальной вершины. Если из начальной вершины можно добраться до любой другой, то граф связный. Нужно проверить, оказались ли все вершины посещенными после работы алгоритма:

```
sum(visited) == len(visited)
```

### Подсчёт весов компонент связности графа

DFS за один <<проход>> выделяет одну компоненту связности. Последовательно запустим алгоритм из ранее непосещённых вершин. Для подсчета веса компоненты связности будем увеличивать значение некоторого счетчика на вес ребра перед каждым новым вызовом DFS.

### Проверка ацикличности графа

Используем трёхцветную раскраску:

- ![#f5f2eb](https://via.placeholder.com/15/f5f2eb/000000?text=+) белый(0) - ранее не посещенные вершины
- ![#61605f](https://via.placeholder.com/15/61605f/000000?text=+) серый(1) - вершины, находящиеся в процессе обработки(алгоритм еще не проверил все вершины, доступные из данной)
- ![#2e2e2d](https://via.placeholder.com/15/2e2e2d/000000?text=+) чёрный(2) - посещённая, обработанная вершина

Изначально все вершины белые. Вершина красится в серый, когда мы заходим в эту вершину. При выходе закрашиваем вершину в чёрный. 

Если существует ребро, ведущее из одной серой вершины в другую серую, то в графе существует цикл. Это легко понять, так как серые вершины формируют некотрый путь в графе. 

### Топологическая сортировка

Пусть задан ациклический, ориентированный граф. Задача: **Найти порядок вершин так, чтобы ребра шли слева направо(ребра идут из более <<ранних>> вершин в более <<поздние>> вершины)**.

Далее будем пользоваться следующим определением:
- **Сток** -- вершина без исходящих ребер.

Очевидно, что в каждом ациклическом, ориентированном графе существует сток.

Для поиска нужного порядка вершин реализуем следующий алгоритм:

1. Найдём сток в графе
2. Запишем найденный сток в массив и удалим его из графа
3. Повторяем шаги 1 - 2 до того момента, пока граф не станет пустым
4. Перевернутый массив - искомый порядок вершин















